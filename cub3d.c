/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   cub3d.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mframbou <mframbou@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2021/11/18 18:05:21 by mframbou          #+#    #+#             */
/*   Updated: 2021/12/01 19:20:57 by mframbou         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minilibx/mlx.h"
#include "cub3d.h"
#include "mlx_keycodes.h"
#include <stdlib.h>

#define mapWidth 24
#define mapHeight 24
#define screenWidth 1280
#define screenHeight 720
#define MOVEMENT_FACTOR 0.075
#define COS_ROTATION 0.99691733373
#define SIN_ROTATION 0.07845909568
#define BOUNDING_BOX_SIDE_SIZE 0.4
#define SPEED_MULTIPLIER 1.5
// Ratio compared to the size of the screen (here it takes 1/10 of the screen)
// map will remain squared (take min(width/ratio), (height/ratio))
// Should not be set to les than 1
#define MINIMAP_SIZE_RATIO 3.75
// Size of one tile represented on the minimap (here it's a square of 5x5)
#define SIZE_OF_TILE_ON_MINIMAP 10
// player sprite size on minimap
#define PLAYER_SIZE_ON_MINIMAP 7

// Cos of rotation angle and sin of rotation angle (directly in radians)
// Current values for 
/*
	2 degrees	= 0,0349066 	rad		(cos = 0.99939082649, sin = 0.03489951165)
	3 degrees	= 0,0523599		rad		(cos = 0.99862953358, sin = 0.05233597865)
	3.5 degrees	= 0.0610865238 	rad		(cos = 0.99813479842, sin = 0.06104853951)
	4.5 degrees = 0.0785398163	rad		(cos = 0.99691733373, sin = 0.07845909568)
	5 degrees	= 0,0872665 	rad		(cos = 0.99619469483, sin = 0.08715578)
*/
int worldMap[mapWidth][mapHeight]=
{
  {1,1,4,2,4,4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
  {4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {3,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {4,0,0,0,0,0,2,4,4,2,2,0,0,0,0,3,0,3,0,3,0,0,0,1},
  {4,0,0,0,0,0,4,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,0,0,0,0,0,4,0,0,0,2,0,0,0,0,3,0,0,0,3,0,0,0,1},
  {1,0,0,0,0,0,4,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,0,0,0,0,0,2,2,0,2,2,0,0,0,0,3,0,3,0,3,0,0,0,1},
  {1,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,4,4,4,4,4,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,4,0,4,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,4,0,0,0,0,5,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,4,0,4,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,4,0,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
  {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}
};
/*
int crossTex[32][32]=
{
	{0x00FF0000,0x00FF0000,0x0000FF00,0x00FF0000,0x00000000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00000000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,},
	{0x00FF0000,0x00FF0000,0x0000FF00,0x00FF0000,0x00000000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00000000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,},
	{0x00FF0000,0x00FF0000,0x0000FF00,0x00FF0000,0x00000000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00000000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,},
	{0x00FF0000,0x00FF0000,0x0000FF00,0x00FF0000,0x00000000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00000000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,},
	{0x00FF0000,0x00FF0000,0x0000FF00,0x00FF0000,0x00000000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00000000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,},
	{0x00FF0000,0x00FF0000,0x0000FF00,0x00FF0000,0x00000000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00000000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,},
	{0x00FF0000,0x00FF0000,0x0000FF00,0x00FF0000,0x00000000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00000000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,},
	{0x00FF0000,0x00FF0000,0x0000FF00,0x00FF0000,0x00000000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00000000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,},
	{0x00FF0000,0x00FF0000,0x0000FF00,0x00FF0000,0x00000000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00000000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,},
	{0x00FF0000,0x00FF0000,0x0000FF00,0x00FF0000,0x00000000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00000000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,},
	{0x00FF0000,0x00FF0000,0x0000FF00,0x00FF0000,0x00000000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00000000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,},
	{0x00FF0000,0x00FF0000,0x0000FF00,0x00FF0000,0x00000000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00000000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,},
	{0x00FF0000,0x00FF0000,0x0000FF00,0x00FF0000,0x00000000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00000000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,},
	{0x00FF0000,0x00FF0000,0x0000FF00,0x00FF0000,0x00000000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00000000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,},
	{0x00000000,0x00000000,0x0000FF00,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,},
	{0x00FF0000,0x00FF0000,0x0000FF00,0x00FF0000,0x00000000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00000000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,},
	{0x00FF0000,0x00FF0000,0x0000FF00,0x00FF0000,0x00000000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00000000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,},
	{0x00FF0000,0x00FF0000,0x0000FF00,0x00FF0000,0x00000000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00000000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,},
	{0x00FF0000,0x00FF0000,0x0000FF00,0x00FF0000,0x00000000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00000000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,},
	{0x00FF0000,0x00FF0000,0x0000FF00,0x00FF0000,0x00000000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00000000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,},
	{0x00FF0000,0x00FF0000,0x0000FF00,0x00FF0000,0x00000000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00000000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,},
	{0x00FF0000,0x00FF0000,0x0000FF00,0x00FF0000,0x00000000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00000000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,},
	{0x00FF0000,0x00FF0000,0x0000FF00,0x00FF0000,0x00000000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00000000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,},
	{0x00FF0000,0x00FF0000,0x0000FF00,0x00FF0000,0x00000000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00000000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,},
	{0x00FF0000,0x00FF0000,0x0000FF00,0x00FF0000,0x00000000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00000000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,},
	{0x00FF0000,0x00FF0000,0x0000FF00,0x00FF0000,0x00000000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00000000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,},
	{0x00FF0000,0x00FF0000,0x0000FF00,0x00FF0000,0x00000000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00000000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,},
	{0x00FF0000,0x00FF0000,0x0000FF00,0x00FF0000,0x00000000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00000000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,},
	{0x00FF0000,0x00FF0000,0x0000FF00,0x00FF0000,0x00000000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00000000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,},
	{0x00FF0000,0x00FF0000,0x0000FF00,0x00FF0000,0x00000000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00000000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,},
	{0x00FF0000,0x00FF0000,0x0000FF00,0x00FF0000,0x00000000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00000000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,},
	{0x00FF0000,0x00FF0000,0x0000FF00,0x00FF0000,0x00000000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00000000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,0x00FF0000,},
};
*/

int crossTex[32][32]=
{
	{0x0032271D,0x00514537,0x00786C5E,0x00796D5F,0x0075695B,0x0055493B,0x0034291E,0x00594D3F,0x00594D3F,0x00524638,0x00534739,0x00514537,0x00534739,0x0034291E,0x0055493B,0x007D7163,0x005A4E40,0x005D5143,0x00524638,0x0054483A,0x00584C3E,0x0054483A,0x0032271D,0x00534739,0x0054483A,0x00352A1F,0x00584C3E,0x00786C5E,0x004E4235,0x00504437,0x00514537,0x00594D3F},
	{0x0034291E,0x00605445,0x00786C5E,0x006A5E4F,0x006B5F50,0x00574B3D,0x00392E23,0x00584C3E,0x0054483A,0x00564A3C,0x00534739,0x00514537,0x00473B2F,0x0031261C,0x00574B3D,0x00786C5E,0x0065594A,0x0065594A,0x00524638,0x00574B3D,0x004C4033,0x00493D30,0x0034291E,0x00483C2F,0x0044392C,0x00493D30,0x0032271D,0x0030261B,0x0030261B,0x00362B20,0x0031261C,0x00534739},
	{0x00524638,0x00786C5E,0x006D6152,0x006B5F50,0x006B5F50,0x00524638,0x0033281E,0x004E4235,0x0054483A,0x00504437,0x0042372A,0x003C3125,0x00473B2F,0x0034291E,0x005A4E40,0x00766A5C,0x00675B4C,0x00665A4B,0x0054483A,0x00564A3C,0x0044392C,0x0041362A,0x00362B20,0x0044392C,0x00453A2D,0x00453A2D,0x0033281E,0x00564A3C,0x00534739,0x004E4235,0x00534739,0x0032271D},
	{0x00564A3C,0x00786C5E,0x006A5E4F,0x006B5F50,0x00645849,0x0041362A,0x00352A1F,0x00453A2D,0x004B3F32,0x00403529,0x0042372A,0x00372C21,0x0033281E,0x0054483A,0x007A6E60,0x00625647,0x005F5345,0x005D5143,0x00493D30,0x003C3125,0x00473B2F,0x00352A1F,0x0033281E,0x00362B20,0x002F251B,0x0033281E,0x0030261B,0x00786C5E,0x00776B5D,0x00786C5E,0x005B4F41,0x0031261C},
	{0x0054483A,0x007B6F61,0x0055493B,0x004E4235,0x00534739,0x003F3428,0x0033281E,0x003D3226,0x0032271D,0x0030261B,0x0033281E,0x00514537,0x00504437,0x00786C5E,0x00504437,0x0054483A,0x00564A3C,0x004E4235,0x0044392C,0x004A3E31,0x0033281E,0x0055493B,0x004F4336,0x0055493B,0x0055493B,0x00504437,0x00807466,0x005D5143,0x005E5244,0x004A3E31,0x00504437,0x00534739},
	{0x0055493B,0x004F4336,0x0055493B,0x00504437,0x00534739,0x00453A2D,0x003C3125,0x002F251B,0x00483C2F,0x0054483A,0x00564A3C,0x00786C5E,0x0075695B,0x00504437,0x00534739,0x004D4134,0x0041362A,0x003E3327,0x003F3428,0x00352A1F,0x005A4E40,0x00786C5E,0x00766A5C,0x007C7062,0x007C7062,0x00504437,0x0034291E,0x00524638,0x005D5143,0x0055493B,0x004D4134,0x004F4336},
	{0x0054483A,0x004E4235,0x0054483A,0x00504437,0x00584C3E,0x004B3F32,0x00392E23,0x002F251B,0x003F3428,0x00605445,0x00786C5E,0x00504437,0x00564A3C,0x00534739,0x0054483A,0x004A3E31,0x00392E23,0x00392E23,0x00392E23,0x0034291E,0x00473B2F,0x00625647,0x00504437,0x00625647,0x00534739,0x0044392C,0x002E241A,0x004B3F32,0x00493D30,0x003F3428,0x00514537,0x00534739},
	{0x0054483A,0x004C4033,0x0054483A,0x005C5042,0x00514537,0x00463A2E,0x0042372A,0x0031261C,0x00473B2F,0x00493D30,0x00524638,0x00473B2F,0x0044392C,0x003F3428,0x0032271D,0x00382D21,0x0032271D,0x0031261C,0x0031261C,0x00352A1F,0x002F251B,0x0044392C,0x004F4336,0x00605445,0x004C4033,0x00453A2D,0x003E3327,0x0034291E,0x00382D21,0x003F3428,0x0032271D,0x00534739},
	{0x004B3F32,0x00453A2D,0x00473B2F,0x004C4033,0x0054483A,0x00483C2F,0x003F3428,0x0030261B,0x002E241A,0x00352A1F,0x00352A1F,0x0030261B,0x00382E22,0x0031261C,0x00524638,0x0074685A,0x007A6E60,0x00796D5F,0x007E7264,0x0075695B,0x003B3025,0x003F3428,0x0031261C,0x00493D30,0x00453A2D,0x003C3125,0x00392E23,0x002F251B,0x00392E23,0x00392E23,0x0033281E,0x002F251B},
	{0x0033281E,0x00463A2E,0x00473B2F,0x0054483A,0x0042372A,0x004A3E31,0x0043382B,0x0034291E,0x00564A3C,0x00574B3D,0x004D4134,0x00493D30,0x0034291E,0x00453A2D,0x00776B5D,0x007A6E60,0x0074685A,0x00605445,0x00534739,0x00564A3C,0x00584C3E,0x0042372A,0x002F251B,0x003A2F24,0x003F3428,0x00382E22,0x0043382B,0x0034291E,0x002F251B,0x004D4134,0x0054483A,0x00504437},
	{0x00463A2E,0x0031261C,0x00493D30,0x0055493B,0x00473B2F,0x00463A2E,0x0041362A,0x00372C21,0x004F4336,0x00786C5E,0x007D7163,0x005A4E40,0x00362B20,0x0055493B,0x00766A5C,0x007A6E60,0x00584C3E,0x005F5345,0x0054483A,0x00514537,0x00574B3D,0x0044392C,0x00493D30,0x002F251B,0x0033281E,0x003A2F24,0x0033281E,0x00594D3F,0x00574B3D,0x007E7264,0x007F7365,0x00786C5E},
	{0x004F4336,0x0032271D,0x0034291E,0x0033281E,0x003F3428,0x00403529,0x0032271D,0x00534739,0x00786C5E,0x006B5F50,0x006C6051,0x0054483A,0x00352A1F,0x004A3E31,0x00675B4C,0x00645849,0x0065594A,0x005E5244,0x004F4336,0x00524638,0x004A3E31,0x00564A3C,0x004D4134,0x004A3E31,0x003E3327,0x0033281E,0x0055493B,0x007E7264,0x0075695B,0x005E5244,0x005B4F41,0x00504437},
	{0x00534739,0x0030261B,0x00584C3E,0x004D4134,0x0033281E,0x0044392C,0x00564A3C,0x00766A5C,0x006C6051,0x006F6354,0x00695D4E,0x00574B3D,0x0032271D,0x004B3F32,0x00665A4B,0x005F5345,0x005D5143,0x00534739,0x0054483A,0x00524638,0x00534739,0x00564A3C,0x00504437,0x00564A3C,0x00463A2E,0x0032271D,0x0054483A,0x007B6F61,0x005D5143,0x005D5143,0x005F5345,0x0054483A},
	{0x00514537,0x0033281E,0x007A6E60,0x00796D5F,0x0032271D,0x00534739,0x00695D4E,0x0065594A,0x006C6051,0x006E6253,0x006C6051,0x00574B3D,0x0031261C,0x00493D30,0x00675B4C,0x005F5345,0x00635748,0x005A4E40,0x00564A3C,0x00514537,0x00584C3E,0x00574B3D,0x0055493B,0x00473B2F,0x002E241A,0x00564A3C,0x00796D5F,0x00605445,0x00695D4E,0x005B4F41,0x005D5143,0x00524638},
	{0x00362B20,0x00605445,0x007C7062,0x00776B5D,0x0030261B,0x00584C3E,0x00786C5E,0x0065594A,0x005B4F41,0x00625647,0x004F4336,0x0044392C,0x00403529,0x002F251B,0x00574B3D,0x00584C3E,0x00493D30,0x005A4E40,0x00574B3D,0x00514537,0x00574B3D,0x00504437,0x00514537,0x00493D30,0x002D2319,0x00524638,0x00786C5E,0x00605445,0x005C5042,0x00514537,0x00493D30,0x0042372A},
	{0x00564A3C,0x00786C5E,0x00625647,0x005C5042,0x00524638,0x00372C21,0x0054483A,0x00504437,0x00473B2F,0x00453A2D,0x00564A3C,0x0055493B,0x00493D30,0x00372C21,0x004C4033,0x00574B3D,0x00584C3E,0x00473B2F,0x00493D30,0x00514537,0x00504437,0x00594D3F,0x00473B2F,0x003F3428,0x0031261C,0x004E4235,0x005E5244,0x00625647,0x00635748,0x0044392C,0x00473B2F,0x0030261B},
	{0x007B6F61,0x00635748,0x00605445,0x005B4F41,0x00483C2F,0x0031261C,0x00493D30,0x004F4336,0x00564A3C,0x00463A2E,0x0042372A,0x00483C2F,0x00382D21,0x0031261C,0x003F3428,0x00473B2F,0x00524638,0x004E4235,0x00473B2F,0x0044392C,0x00493D30,0x004D4134,0x00392E23,0x0031261C,0x004F4336,0x0033281E,0x00564A3C,0x004A3E31,0x003D3226,0x003C3125,0x0031261C,0x007A6E60},
	{0x00736758,0x00564A3C,0x0054483A,0x00514537,0x004B3F32,0x0030261B,0x004B3F32,0x00493D30,0x0055493B,0x0054483A,0x00403529,0x00392E23,0x00372C21,0x0032271D,0x003B3025,0x003E3327,0x0044392C,0x00504437,0x00504437,0x00524638,0x00504437,0x003E3327,0x003D3226,0x0030261B,0x004E4235,0x0055493B,0x002E241A,0x0034291E,0x002F251B,0x0030261B,0x00403529,0x007A6E60},
	{0x00534739,0x00564A3C,0x00574B3D,0x00504437,0x00403529,0x0032271D,0x002F251B,0x00524638,0x00504437,0x00473B2F,0x0042372A,0x003D3226,0x0030261B,0x00403529,0x0031261C,0x0031261C,0x0032271D,0x004C4033,0x004B3F32,0x0044392C,0x003F3428,0x00382E22,0x00362B20,0x00514537,0x007F7365,0x00776B5D,0x00766A5C,0x0055493B,0x00392E23,0x002F251B,0x00403529,0x00524638},
	{0x00534739,0x00584C3E,0x00564A3C,0x00473B2F,0x0041362A,0x003B3025,0x00524638,0x00362B20,0x0044392C,0x0042372A,0x00473B2F,0x00362B20,0x00524638,0x007F7365,0x00493D30,0x0042372A,0x00473B2F,0x00352A1F,0x0031261C,0x003A2F24,0x0032271D,0x003A2F24,0x0034291E,0x004C4033,0x00786C5E,0x005E5244,0x005B4F41,0x00504437,0x003A2F24,0x0031261C,0x003F3428,0x0055493B},
	{0x00584C3E,0x005C5042,0x004E4235,0x004C4033,0x0033281E,0x00564A3C,0x00796D5F,0x00382D21,0x00352A1F,0x0032271D,0x003A2F24,0x00514537,0x007D7163,0x00786C5E,0x00796D5F,0x00786C5E,0x0074685A,0x00574B3D,0x00524638,0x0032271D,0x0034291E,0x0031261C,0x00524638,0x00796D5F,0x00605445,0x005E5244,0x00615546,0x00574B3D,0x004B3F32,0x0042372A,0x0030261B,0x00514537},
	{0x00584C3E,0x00504437,0x004B3F32,0x003F3428,0x00504437,0x007C7062,0x00382D21,0x00574B3D,0x004C4033,0x0055493B,0x0074685A,0x007A6E60,0x00685C4D,0x00605445,0x005D5143,0x0054483A,0x00524638,0x0034291E,0x004D4134,0x00362B20,0x0054483A,0x00584C3E,0x00796D5F,0x00605445,0x005D5143,0x00615546,0x0044392C,0x00403529,0x003A2F24,0x003E3327,0x00362B20,0x00534739},
	{0x00493D30,0x00473B2F,0x00473B2F,0x0031261C,0x005F5345,0x007A6E60,0x005D5143,0x00372C21,0x004E4235,0x007C7062,0x00786C5E,0x00766A5C,0x00645849,0x00645849,0x00615546,0x00605445,0x00564A3C,0x00504437,0x0032271D,0x00564A3C,0x005C5042,0x0034291E,0x0033281E,0x00473B2F,0x00473B2F,0x00473B2F,0x003B3025,0x00403529,0x00392E23,0x003B3025,0x003F3428,0x00372C21},
	{0x00372C21,0x00382D21,0x0031261C,0x0055493B,0x0075695B,0x0054483A,0x0055493B,0x00352A1F,0x004E4235,0x007B6F61,0x005F5345,0x00665A4B,0x00635748,0x00594D3F,0x00483C2F,0x004D4134,0x00493D30,0x0033281E,0x005A4E40,0x00766A5C,0x00807466,0x00564A3C,0x00514537,0x0031261C,0x00403529,0x0042372A,0x00352A1F,0x003A2F24,0x0032271D,0x00362B20,0x00362B20,0x004E4235},
	{0x0055493B,0x00382E22,0x004D4134,0x00766A5C,0x005E5244,0x00564A3C,0x00473B2F,0x0031261C,0x0032271D,0x0055493B,0x005F5345,0x00615546,0x005D5143,0x00514537,0x00473B2F,0x00534739,0x00473B2F,0x0033281E,0x00534739,0x00776B5D,0x007A6E60,0x00786C5E,0x0074685A,0x00483C2F,0x0032271D,0x0034291E,0x002F251B,0x0031261C,0x003F3428,0x0055493B,0x0054483A,0x00534739},
	{0x00524638,0x0032271D,0x00574B3D,0x007C7062,0x004B3F32,0x0031261C,0x0042372A,0x00473B2F,0x00564A3C,0x00392E23,0x0034291E,0x002D2319,0x0055493B,0x00504437,0x00473B2F,0x0043382B,0x00453A2D,0x00382E22,0x00564A3C,0x00766A5C,0x005E5244,0x00605445,0x004E4235,0x005A4E40,0x004B3F32,0x00564A3C,0x0034291E,0x0041362A,0x00453A2D,0x00534739,0x004D4134,0x0055493B},
	{0x0042372A,0x00483C2F,0x00352A1F,0x00574B3D,0x0032271D,0x004B3F32,0x00534739,0x00786C5E,0x00766A5C,0x00796D5F,0x00786C5E,0x0054483A,0x0033281E,0x00483C2F,0x003D3226,0x00392E23,0x00352A1F,0x004B3F32,0x007A6E60,0x00796D5F,0x0065594A,0x005E5244,0x00584C3E,0x00504437,0x00574B3D,0x0044392C,0x00382D21,0x00463A2E,0x004B3F32,0x00524638,0x00514537,0x004F4336},
	{0x00473B2F,0x00493D30,0x0030261B,0x0044392C,0x0032271D,0x00453A2D,0x006B5F50,0x00675B4C,0x006B5F50,0x005B4F41,0x005D5143,0x007A6E60,0x00524638,0x0031261C,0x00372C21,0x00372C21,0x0032271D,0x00483C2F,0x00766A5C,0x005D5143,0x00645849,0x00514537,0x004D4134,0x004D4134,0x00564A3C,0x00473B2F,0x0030261B,0x0034291E,0x0031261C,0x0034291E,0x00564A3C,0x0054483A},
	{0x002E241A,0x0044392C,0x002F251B,0x0032271D,0x00352A1F,0x00534739,0x00766A5C,0x0065594A,0x006C6051,0x005F5345,0x00605445,0x0054483A,0x00453A2D,0x0030261B,0x0030261B,0x0031261C,0x003E3327,0x00493D30,0x005E5244,0x005E5244,0x005B4F41,0x00534739,0x00514537,0x004E4235,0x00403529,0x002F251B,0x004B3F32,0x00483C2F,0x00493D30,0x00504437,0x002E241A,0x002F251B},
	{0x00514537,0x00453A2D,0x00453A2D,0x0031261C,0x00574B3D,0x007A6E60,0x005E5244,0x00605445,0x00504437,0x00574B3D,0x00403529,0x0031261C,0x003A2F24,0x003A2F24,0x00453A2D,0x0031261C,0x00352A1F,0x00392E23,0x0055493B,0x004F4336,0x00524638,0x0054483A,0x00463A2E,0x0042372A,0x0033281E,0x004D4134,0x007B6F61,0x00766A5C,0x007A6E60,0x00504437,0x00534739,0x00534739},
	{0x0034291E,0x0055493B,0x007B6F61,0x00736758,0x0030261B,0x004D4134,0x00534739,0x0055493B,0x00574B3D,0x00564A3C,0x00493D30,0x00403529,0x0031261C,0x00392E23,0x00403529,0x00534739,0x004E4235,0x00534739,0x00584C3E,0x00372C21,0x00564A3C,0x0055493B,0x00524638,0x00493D30,0x0034291E,0x0055493B,0x00776B5D,0x0055493B,0x0054483A,0x00504437,0x0054483A,0x00524638},
	{0x00362B20,0x00524638,0x00736758,0x00796D5F,0x0034291E,0x00504437,0x00534739,0x00574B3D,0x00584C3E,0x00493D30,0x0044392C,0x0034291E,0x003F3428,0x003E3327,0x00473B2F,0x00534739,0x00564A3C,0x00534739,0x00574B3D,0x005A4E40,0x00372C21,0x0044392C,0x004B3F32,0x004B3F32,0x0030261B,0x00574B3D,0x00796D5F,0x0054483A,0x00504437,0x0055493B,0x00534739,0x00584C3E}
};
/*	     X
	+-------->
	|
  Y |
	|
	V
*/

#include <sys/time.h>
#include <stdio.h>

void print_elapsed(char str[], struct timeval start)
{
	struct timeval now;

	gettimeofday(&now, NULL);
	int diff_s = now.tv_sec - start.tv_sec;
	int diff_u = now.tv_usec - start.tv_usec;
	printf("%s %d elapsed\n", str, (diff_s * 1000 * 1000 + diff_u));
}

void	mlx_put_pixel_img(t_img_data *img, int x, int y, int color)
{
	char	*dst;
	struct timeval start;

	//gettimeofday(&start, NULL);
	//print_elapsed("start put pixel: ", start);
	
	dst = img->addr + (y * img->line_length + x * (img->bits_per_pixel / 8));
	
	//((unsigned int*) img->addr)[y * screenWidth + x] = color; // maybe faster ?

	*((unsigned int *)dst) = color;
	//print_elapsed("end put pixel: ", start);
}

inline double	ft_lerp(double min, double max, double val)
{
	return (min + val * (max - min));
}

#include <stdio.h>

double	pow_two(double num)
{
	return (num * num);
}

t_point	get_pos_current_tile(t_vector player_pos)
{
	t_point	res;

	res.x = (int) player_pos.x;
	res.y = (int) player_pos.y;
	return (res);
}

t_point	get_pos_current_tile_floor(t_vector player_pos)
{
	t_point	res;

	res.x = (int) floor(player_pos.x);
	res.y = (int) floor(player_pos.y);
	return (res);
}

int	min(int a, int b)
{
	if (a < b)
		return (a);
	return (b);
}

t_game		game;


void	mlx_put_line_to_img(t_img_data *img,
	t_point start, t_point end, int color)
{
	float		delta_x;
	float		delta_y;
	int			pixels_count;
	float		pixel_x;
	float		pixel_y;

	delta_x = end.x - start.x;
	delta_y = end.y - start.y;
	pixels_count = (int) sqrtl(delta_x * delta_x + delta_y * delta_y);
	delta_x = delta_x / (float) pixels_count;
	delta_y = delta_y / (float) pixels_count;
	pixel_x = start.x;
	pixel_y = start.y;
	while (pixels_count)
	{
		mlx_put_pixel_img(img, (int) lround(pixel_x),
			(int) lround(pixel_y), color);
		pixel_x += delta_x;
		pixel_y += delta_y;
		pixels_count--;
	}
}

int sign (t_point p1, t_point p2, t_point p3)
{
    return ((p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y));
}

int	is_point_in_triangle(t_point pt, t_point v1, t_point v2, t_point v3)
{
    int d1, d2, d3;
    int has_neg, has_pos;

    d1 = sign(pt, v1, v2);
    d2 = sign(pt, v2, v3);
    d3 = sign(pt, v3, v1);

	has_neg = 0;
	has_pos = 0;
    if ((d1 < 0) || (d2 < 0) || (d3 < 0))
		has_neg = 1;
    if ((d1 > 0) || (d2 > 0) || (d3 > 0))
		has_pos = 1;

	//printf("pt %d %d has_pos: %d, neg: %d\n",pt.x, pt.y, has_pos, has_neg);
	if (has_neg && has_pos)
		return(0);
	return (1);
}

int	get_min_y(t_point t1, t_point t2, t_point t3)
{
	int	y1;
	int	y2;
	int	y3;

	y1 = t1.y;
	y2 = t2.y;
	y3 = t3.y;
	if (y1 <= y2 && y1 <= y3)
		return (y1);
	else if (y2 <= y1 && y2 <= y3)
		return (y2);
	else
		return (y3);
}

int	get_max_y(t_point t1, t_point t2, t_point t3)
{
	int	y1;
	int	y2;
	int	y3;

	y1 = t1.y;
	y2 = t2.y;
	y3 = t3.y;
	if (y1 >= y2 && y1 >= y3)
		return (y1);
	else if (y2 >= y1 && y2 >= y3)
		return (y2);
	else
		return (y3);
}

int	get_min_x(t_point t1, t_point t2, t_point t3)
{
	int	x1;
	int	x2;
	int	x3;

	x1 = t1.x;
	x2 = t2.x;
	x3 = t3.x;
	if (x1 <= x2 && x1 <= x3)
		return (x1);
	else if (x2 <= x1 && x2 <= x3)
		return (x2);
	else
		return (x3);
}

int	get_max_x(t_point t1, t_point t2, t_point t3)
{
	int	x1;
	int	x2;
	int	x3;

	x1 = t1.x;
	x2 = t2.x;
	x3 = t3.x;
	if (x1 >= x2 && x1 >= x3)
		return (x1);
	else if (x2 >= x1 && x2 >= x3)
		return (x2);
	else
		return (x3);
}

void	draw_player_pos_dir(t_vector player_dir, t_img_data *img, int x, int y)
{	
	t_vector	normalized_dir;
	t_vector	perp_dir;
	t_point		t1;
	t_point		t2;
	t_point		top;
	int			i;

	double vec_len = sqrt(pow_two(player_dir.x) + pow_two(player_dir.y));
	player_dir.x /= vec_len;
	player_dir.y /= vec_len;
	perp_dir.x = -player_dir.y;
	perp_dir.y = player_dir.x;
	normalized_dir.x = player_dir.x;
	normalized_dir.y = player_dir.y;
	i = 0;
	while (i < PLAYER_SIZE_ON_MINIMAP)
	{
		//mlx_put_pixel_img(img, (int) player_dir.x + x, (int) player_dir.y + y, 0x00FF8855);
		player_dir.x += normalized_dir.x;
		player_dir.y += normalized_dir.y;
		i++;
	}
	top.x = player_dir.x + x;
	top.y = player_dir.y + y;
	i = 0;
	while (i < (int)((float) PLAYER_SIZE_ON_MINIMAP / 2.5))
	{
		//mlx_put_pixel_img(img, (int) perp_dir.x + x, (int) perp_dir.y + y, 0x00FF8855);
		//mlx_put_pixel_img(img, (int) -perp_dir.x + x, (int) -perp_dir.y + y, 0x00FF8855);
		perp_dir.x += (-normalized_dir.y);
		perp_dir.y += (normalized_dir.x);
		i++;
	}
	t1.x = perp_dir.x + x;
	t1.y = perp_dir.y + y;
	t2.x = -perp_dir.x + x;
	t2.y = -perp_dir.y + y;
	t_point	pt;
	//printf("t1 %d %d   t2 %d %d    top %d %d\n", t1.x, t1.y, t2.x, t2.y, top.x, top.y);
	//printf("x- min: %d max; %d  -- y- min:%d max:%d\n", get_min_x(t1, t2, top),get_max_x(t1, t2, top), get_min_y(t1, t2, top),get_max_y(t1, t2, top));
	for (int i = get_min_x(t1, t2, top); i <= get_max_x(t1, t2, top); i++)
	{
		for (int j = get_min_y(t1, t2, top); j <= get_max_y(t1, t2, top); j++)
		{
			/*pt.x = perp_dir.x - i + x;
			pt.y = perp_dir.y - j + y;
			*/
			pt.x = i;
			pt.y = j;
			if (is_point_in_triangle(pt, t1, t2, top))
				mlx_put_pixel_img(img, pt.x, pt.y, 0x00FF8855);
		}
	}
}

void	add_minimap(int map[24][24])
{
	int			minimap_size;
	t_vector	current_pos;
	double		offset_every_px;
	t_point		current_tile;

	int x = 0;
	int y = 0;
	minimap_size = min(screenHeight / MINIMAP_SIZE_RATIO, screenWidth / MINIMAP_SIZE_RATIO);
	current_pos.x = game.player.pos.x - ((double) minimap_size / (double) SIZE_OF_TILE_ON_MINIMAP) / 2.0;
	current_pos.y = game.player.pos.y - ((double) minimap_size / (double) SIZE_OF_TILE_ON_MINIMAP) / 2.0;
	offset_every_px = ((double) minimap_size / (double) SIZE_OF_TILE_ON_MINIMAP) / (double) minimap_size;
	//printf("current_pos: (%f, %f)\n", current_pos.x, current_pos.y);
	//printf("current offset: (%f, %f)\n", offset_every_px, offset_every_px);
	//printf("minimap size: (%d, %d)\n", minimap_size, minimap_size);
	while (y < minimap_size)
	{
		x = 0;
		current_pos.x = game.player.pos.x - ((double) minimap_size / SIZE_OF_TILE_ON_MINIMAP) / 2;
		while (x < minimap_size)
		{
			// If we are at pos -0, truncating will give 0, floor will give -1
			// So when we were on -x and -y, walls would actually appear 2x thicccer
			// That's why I use floor only for this function (since i think it's more intensive)
			current_tile = get_pos_current_tile_floor(current_pos);
			//printf("current_pos: (%f, %f), x:%d, y:%d\n", current_pos.x, current_pos.y, x, y);
			//printf("current tile: %d %d\n", current_tile.x, current_tile.y);
			mlx_put_pixel_img(&game.minimap_img, x, y, 0x88FFFFFF);
			//printf("x_pos:%f, floored:%d\n", current_pos.x, current_tile.x);
			if (current_tile.x >= 0 && current_tile.y >= 0 && current_tile.x < 24 && current_tile.y < 24)
			{
				//printf("current tile: %d %d\n", current_tile.x, current_tile.y);
				
				if (map[current_tile.y][current_tile.x] != 0)
				{
					//printf("put pixel %d %d\n",x,y);
					
					mlx_put_pixel_img(&game.minimap_img, x, y, 0x00ff00bb);
				}
			}
			
			current_pos.x += offset_every_px;
			x++;
		}
		current_pos.y += offset_every_px;
		y++;
	}
	draw_player_pos_dir(game.player.direction, &game.minimap_img, minimap_size / 2, minimap_size / 2);
	/*
	mlx_put_pixel_img(&game.main_img, minimap_size / 2 - 1, minimap_size / 2 + -1, 0x0080FFFF);
	mlx_put_pixel_img(&game.main_img, minimap_size / 2, minimap_size / 2 + -1, 0x0080FFFF);
	mlx_put_pixel_img(&game.main_img, minimap_size / 2 + 1, minimap_size / 2 + -1, 0x0080FFFF);

	mlx_put_pixel_img(&game.main_img, minimap_size / 2 - 1, minimap_size / 2 + -0, 0x0080FFFF);
	mlx_put_pixel_img(&game.main_img, minimap_size / 2, minimap_size / 2, 0x0080FFFF);
	mlx_put_pixel_img(&game.main_img, minimap_size / 2 + 1, minimap_size / 2, 0x0080FFFF);

	mlx_put_pixel_img(&game.main_img, minimap_size / 2 - 1, minimap_size / 2 + 1, 0x0080FFFF);
	mlx_put_pixel_img(&game.main_img, minimap_size / 2, minimap_size / 2 + 1, 0x0080FFFF);
	mlx_put_pixel_img(&game.main_img, minimap_size / 2 + 1, minimap_size / 2 + 1, 0x0080FFFF);
	*/
}

void	drawline_from_distance(int x, double wall_pos_hit, t_ray_hit ray_hit, t_vector ray_dir)
{
	int	line_height = round(((double)screenHeight / ray_hit.distance));
	unsigned int	color = 0x00000FFF;
/*
	struct timeval start;
	gettimeofday(&start, NULL);
	print_elapsed("start put img: ", start);
*/
	int drawStart = -line_height / 2 + screenHeight / 2;
    int drawEnd = line_height / 2 + screenHeight / 2;
	
	
	//print_elapsed("calculs: ", start);
	/*switch(wall_type)
	{
		case 1:
			color = 0x00FF0000;
			break; //red
        case 2:
			color = 0x0000FF00;
			break; //green
        case 3:
			color = 0x000000FF;
			break; //blue
        case 4:
			color = 0x00FFFFFF;
			break; //white
        default:
			color = wall_type;
			break; //yellow
	}*/
	
	if (ray_hit.side_hit == 'y')
		color = color | 0x88000000;
	//print_elapsed("colors: ", start);
	int y = 0;

	//unsigned int	*img_addr;

	//img_addr = (unsigned int *) game.main_img.addr;
	int textureX = (1.0 - wall_pos_hit) * 32.0;
	if(ray_hit.side_hit == 'x' && ray_dir.x > 0)
		textureX = 32.0 - textureX - 1.0;
    if(ray_hit.side_hit == 'y' && ray_dir.y < 0)
		textureX = 32.0 - textureX - 1.0;
	double stepY = 1.0 * 32.0 / (double) line_height;
	double textureY = 0.0 ; // start from middle of texture and go either top or down way
	
	/*if (drawStart < 0)
	{
		// divide by two since same overlap on top and bottom
		//textureY = ((double)-drawStart / (double)screenHeight) / 2.0 * 32.0;
		//printf("-%d / %d * 32.0 = %f\n", drawStart, screenHeight, textureY);
	}*/
	
	/*if (x == screenWidth / 2)
	{
		printf("drawstart: %d, line height: %d, distance: %f\n" ,drawStart, line_height, ray_hit.distance);
		printf("textureY start: %f, step: %f\n", textureY, stepY);
	}*/

	// If the texture is bigger than the screen, just "simulate" going x (until start of screen)
	// and adding a step each time, so just "move" on texture (0 - drawstart) times
	if (drawStart < 0)
	{
		textureY += (stepY * -drawStart);
	}
	if(drawStart < 0)
		drawStart = 0;

	if(drawEnd >= screenHeight)
		drawEnd = screenHeight - 1;
		
	//print_elapsed("calculs put img: ", start);
	while (y < drawStart)
	{
		//img_addr[x + y * screenWidth] = 0x00231570;
		//y++;

		//((unsigned int*) game.main_img.addr)[y++ * screenWidth + x] = 0x00231570; not faster
		mlx_put_pixel_img(&game.main_img, x, y++, 0x00231570);
	}
	//print_elapsed("sky: ", start);
	while (y <= drawEnd)
	{
		//img_addr[x + y * screenWidth] = color;
		//y++;
		if (textureY > 31.0)
			textureY = 31.0;
		if (textureX > 31.0)
			textureX = 31.0;
		int texColor = crossTex[(int) textureY][textureX];

		//((unsigned int*) game.main_img.addr)[y++ * screenWidth + x] = texColor; not faster
		mlx_put_pixel_img(&game.main_img, x, y++, texColor);

		textureY += stepY;
	}
	//print_elapsed("tex: ", start);
	while (y < screenHeight)
	{
		//img_addr[x + y * screenWidth] = 0x00ede482;
		//y++;

		//((unsigned int*) game.main_img.addr)[y++ * screenWidth + x] = 0x00ede482; not faster
		mlx_put_pixel_img(&game.main_img, x, y++, 0x00ede482);
	}
	//print_elapsed("floor: ", start);
	//print_elapsed("put pixels: ", start);
	// Around 10us using mlx put pixel to put all pixels for a line (start 0 calculs 2 colors 4 put pixels 14)
}

/*
	Return the Y needed to go from X to X+1 based on the given direction
	If the vector is going straight top / bottom, then the needed Y to go to the next
	X is infinite (since it's going straight it will never encounter any horizontal lines)
	So return a very very high value
*/
double	get_y_for_1x_step(t_vector direction)
{
	if (direction.y != 0)
		return (sqrt(1 + pow_two(direction.x) / pow_two(direction.y)));
	else
		return (10E35);
}

/*
	Return the X needed to go fmor Y to Y+1 based on the given direction
	If the vector is going straight right / left, then the needed X to go to the next
	Y is infinite (since it's going straight it will never encounter any vertical lines)
*/
double	get_x_for_1y_step(t_vector direction)
{
	if (direction.x != 0)
		return (sqrt(1 + pow_two(direction.y) / pow_two(direction.x)));
	else
		return (10E35);
}

static double get_dda_x_distance(t_vector direction)
{
	if (direction.x == 0)
		return (1E30);
	else
		return (fabs(1.0 / direction.x));
}

static double get_dda_y_distance(t_vector direction)
{
	if (direction.y == 0)
		return (1E30);
	else
		return (fabs(1.0 / direction.y));
}

t_vector	get_dda_distances(t_vector direction)
{
	t_vector	res;

	res.x = get_dda_x_distance(direction);
	res.y = get_dda_y_distance(direction);
	return (res);
}



t_point	get_direction_steps(t_vector direction)
{
	t_point	step;

	if (direction.x < 0)
		step.x = -1;
	else
		step.x = 1;
	if (direction.y < 0)
		step.y = -1;
	else
		step.y = 1;
	return (step);
}

// player position relative to the tile (between 0-1; 0-1)
// if ray is going left, then relative position = distance from left (default)
// if ray is going right, relative position = distance from right (1 - position)
t_vector	init_base_distances(t_vector direction, t_vector dda_distances, t_vector player_pos)
{
	t_vector	distances;
	t_vector	player_relative_pos;

	player_relative_pos.x = (player_pos.x - (double)((int) player_pos.x));
	player_relative_pos.y = (player_pos.y - (double)((int) player_pos.y));
	if (direction.x < 0)
		distances.x = player_relative_pos.x * dda_distances.x;
	else
		distances.x = (1.0 - player_relative_pos.x) * dda_distances.x;
	if (direction.y < 0)
		distances.y = player_relative_pos.y * dda_distances.y;
	else
		distances.y = (1.0 - player_relative_pos.y) * dda_distances.y;
	return (distances);
}

static t_ray_hit	get_ray_distance_side(t_ray ray, int map[24][24])
{
	t_ray_hit	ray_hit;

	while (1)
	{
		if (ray.total_distances.x < ray.total_distances.y)
		{
			ray.total_distances.x += ray.dda_distances.x;
			ray.current_tile.x += ray.direction_steps.x;
			ray_hit.side_hit = 'x';
		}
		else
		{
			ray.total_distances.y += ray.dda_distances.y;
			ray.current_tile.y += ray.direction_steps.y;
			ray_hit.side_hit = 'y';
		}
		if (map[ray.current_tile.y][ray.current_tile.x] != 0)
			break ;
	}
	if (ray_hit.side_hit == 'x')
		ray_hit.distance = ray.total_distances.x - ray.dda_distances.x;
	else
		ray_hit.distance = ray.total_distances.y - ray.dda_distances.y;
	ray_hit.tile_hit = ray.current_tile;
	return (ray_hit);
}

t_ray_hit	get_ray_hit(t_vector direction, int map[24][24], t_vector player_pos)
{
	t_ray		ray;
	t_ray_hit	ray_hit;

	//struct timeval start;

	//print_elapsed("start:", start);
	ray.direction = direction;
	ray.current_tile = get_pos_current_tile(player_pos);
	//print_elapsed("get tile:", start);
	ray.dda_distances = get_dda_distances(ray.direction);
	//print_elapsed("get dda:", start);
	ray.direction_steps = get_direction_steps(ray.direction);
	//print_elapsed("get steps:", start);
	ray.total_distances = init_base_distances(ray.direction, \
											ray.dda_distances, player_pos);
	//print_elapsed("get base distances:", start);
	ray_hit = get_ray_distance_side(ray, map);
	//print_elapsed("dda:", start);
	return (ray_hit);
}





/* Moving left / right (rotate direction vector by 90 to get velocity vector)
	Rotate a vector:
	x2 = x * cos(90) - y * sin(90)
	y2 = x * sin(90) + y * cos(90)

	x2 = x * cos(pi/2) - y * sin(pi/2)
	y2 = x * sin(pi/2) - y * cos(pi/2)

	x2 = x * 0 - y * 1
	y2 = x * 1 - y * 0

	x2 = 0 - y * 1
	y2 = x * 1 - 0

	(90 degrees)
	x2 = -y
	y2 = x

	(-90 degrees)
	x2 = y
	y2 = -x
*/

/* Rotating left / right

	x2 = x * cos(0.1) - y * sin (0.1)
	y2 = x * sin(0.1) + y * cos(0.1)

	x2 = x * 0.1 - y * 0.01
	y2 = x * 0.01 + y * 0.1
*/

void	add_velocity(t_player *player, double x_direction, double y_direction)
{
	player->velocity.x += x_direction * MOVEMENT_FACTOR;
	player->velocity.y += y_direction * MOVEMENT_FACTOR;
}

void	remove_velocity(t_player *player, double x_direction, double y_direction)
{
	player->velocity.x -= x_direction * MOVEMENT_FACTOR;
	player->velocity.y -= y_direction * MOVEMENT_FACTOR;
}

void	reset_velocity(t_player *player)
{
	player->velocity.x = 0;
	player->velocity.y = 0;
}
/*
	Direction 1 = right, -1 = left
	0.1 radians ~= 5.7 degrees
	0.995 = cos(0.1)
	0.0998 = sin(0.1)
*/
void	rotate_player(t_player *player, int direction)
{
	double	player_x_dir;
	double	player_y_dir;
	double	cam_x_dir;
	double	cam_y_dir;

	reset_velocity(player);
	player_x_dir = player->direction.x;
	player_y_dir = player->direction.y;
	cam_x_dir = player->cam_plane.x;
	cam_y_dir = player->cam_plane.y;
	player->direction.x = (player_x_dir * COS_ROTATION - player_y_dir * (SIN_ROTATION * direction));
	player->direction.y = (player_x_dir * (SIN_ROTATION * direction) + player_y_dir * COS_ROTATION);
	player->cam_plane.x = (cam_x_dir * COS_ROTATION - cam_y_dir * (SIN_ROTATION * direction));
	player->cam_plane.y = (cam_x_dir * (SIN_ROTATION * direction) + cam_y_dir * COS_ROTATION);
	if (player->directions.forward == 1)
		add_velocity(player, player->direction.x, player->direction.y);
	if (player->directions.backward == 1)
		add_velocity(player, -player->direction.x, -player->direction.y);
	if (player->directions.left == 1)
		add_velocity(player, player->direction.y, -player->direction.x);
	if (player->directions.right == 1)
		add_velocity(player, -player->direction.y, player->direction.x);
}



/*
	Rotate_player function automatically readjust velocity
*/
int	key_press_event(int keycode, t_game *game)
{
	t_player	*player;

	if (keycode == KEY_ESC)
		exit(0);
	player = &game->player;
	if (keycode == KEY_W)
	{
		player->directions.forward = 1;
		add_velocity(player, player->direction.x, player->direction.y);
	}
	else if (keycode == KEY_S)
	{
		player->directions.backward = 1;
		add_velocity(player, -player->direction.x, -player->direction.y);
	}
	else if (keycode == KEY_A)
	{
		player->directions.left = 1;
		add_velocity(player, player->direction.y, -player->direction.x);
	}
	else if (keycode == KEY_D)
	{
		player->directions.right = 1;
		add_velocity(player, -player->direction.y, player->direction.x);
	}
	else if (keycode == KEY_SHFT)
	{
		player->speed *= (double) SPEED_MULTIPLIER;
	}
	else if (keycode == KEY_CTRL)
	{
		player->speed /= (double) SPEED_MULTIPLIER;
	}
	else if (keycode == KEY_ARROW_LEFT)
	{
		player->directions.rotate_l = 1;
		rotate_player(player, -1);
	}
	else if (keycode == KEY_ARROW_RIGHT)
	{
		player->directions.rotate_r = 1;
		rotate_player(player, 1);
	}
	else if (keycode == KEY_MINUS) // Increase FOV
	{
		game->player.cam_plane.x *= 1.1;
		game->player.cam_plane.y *= 1.1;
	}
	else if (keycode == KEY_PLUS) // Decrease FOV
	{
		game->player.cam_plane.x *= 0.9;
		game->player.cam_plane.y *= 0.9;
	}
	//printf("%f %f\n", game->player.cam_plane.x, game->player.cam_plane.y);
}





/* OLD
	if (player->directions.forward == 1)
	{
		player->velocity.x += player->direction.x * MOVEMENT_FACTOR;
		player->velocity.y += player->direction.y * MOVEMENT_FACTOR;
	}
	else if (player->directions.backward == 1)
	{
		player->velocity.x += -(player->direction.x * MOVEMENT_FACTOR);
		player->velocity.y += -(player->direction.y * MOVEMENT_FACTOR);
	}
	else if (player->directions.left == 1)
	{
		player->velocity.x += (player->direction.y * MOVEMENT_FACTOR);
		player->velocity.y += -(player->direction.x * MOVEMENT_FACTOR);
	}
	else if (player->directions.right == 1)
	{
		player->velocity.x += -(player->direction.y * MOVEMENT_FACTOR);
		player->velocity.y += (player->direction.x * MOVEMENT_FACTOR);
	}
	else if (player->directions.rotate_l == 1)
	{
		rotate_player(player, -1);
	}
	else if (player->directions.rotate_r == 1)
	{
		rotate_player(player, 1);
	}
*/
/*
	Before rotating, remove the actual velocity, rotate it and put it back
*/

void	add_player_movements(t_player *player)
{
	if (player->directions.forward == 1)
		add_velocity(player, player->direction.x, player->direction.y);
	else if (player->directions.backward == 1)
		add_velocity(player, -player->direction.x, -player->direction.y);
	else if (player->directions.left == 1)
		add_velocity(player, player->direction.y, -player->direction.x);
	else if (player->directions.right == 1)
		add_velocity(player, -player->direction.y, player->direction.x);
	else if (player->directions.rotate_l == 1)
	{
		reset_velocity(player);
		rotate_player(player, -1);
	}
	else if (player->directions.rotate_r == 1)
	{
		reset_velocity(player);
		rotate_player(player, 1);
	}
}

int	point_intersects_wall(t_vector point, int map[24][24])
{
	t_point	current_tile;

	current_tile = get_pos_current_tile(point);
	if (map[current_tile.y][current_tile.x] != 0)
		return (1);
	return (0);
}

int	has_intersection_with_wall(t_vector player_pos, int map[24][24])
{
	t_vector	bounding_box_bot_left;
	t_vector	bouding_box_bot_right;
	t_vector	bounding_box_top_left;
	t_vector	bouding_box_top_right;
	t_point		current_tile;

	bounding_box_bot_left.x = player_pos.x - BOUNDING_BOX_SIDE_SIZE / 2;
	bounding_box_bot_left.y = player_pos.y - BOUNDING_BOX_SIDE_SIZE / 2;
	bouding_box_bot_right.x = player_pos.x + BOUNDING_BOX_SIDE_SIZE / 2;
	bouding_box_bot_right.y = player_pos.y - BOUNDING_BOX_SIDE_SIZE / 2;
	bouding_box_top_right.x = player_pos.x + BOUNDING_BOX_SIDE_SIZE / 2;
	bouding_box_top_right.y = player_pos.y + BOUNDING_BOX_SIDE_SIZE / 2;
	bounding_box_top_left.x = player_pos.x - BOUNDING_BOX_SIDE_SIZE / 2;
	bounding_box_top_left.y = player_pos.y + BOUNDING_BOX_SIDE_SIZE / 2;
	
	if (point_intersects_wall(bounding_box_top_left, map) \
		|| point_intersects_wall(bouding_box_top_right, map) \
		|| point_intersects_wall(bounding_box_bot_left, map) \
		|| point_intersects_wall(bouding_box_bot_right, map))
	{
		return (1);
	}
	return (0);
}

double	get_vector_length(t_vector vector)
{
	return (sqrt(pow_two(vector.x) + pow_two(vector.y)));
}

void	do_render(t_game *game)
{
	t_vector	ray_dir;
	t_vector 	direction;
	double		dda_x_distance;
	double		dda_y_distance;
	double		camera_pos_on_plane;

	direction.x = game->player.direction.x;
	direction.y = game->player.direction.y;
	
	/*
		struct timeval start;
		gettimeofday(&start, NULL);
		print_elapsed("\nstart: ", start);
	*/
	for (int x = 0; x < screenWidth; x++)
	{
		/*
		struct timeval start;
		gettimeofday(&start, NULL);
		print_elapsed("start:", start);
*/
		camera_pos_on_plane = (2.0 * x) / (double) screenWidth - 1;
		ray_dir.x = direction.x + (game->player.cam_plane.x * camera_pos_on_plane);
		ray_dir.y = direction.y + (game->player.cam_plane.y * camera_pos_on_plane);
		t_ray_hit ray_hit = get_ray_hit(ray_dir, worldMap, game->player.pos);



		double	wall_pos_hit;
		double	rel_player_pos;
		if (ray_hit.side_hit == 'x')
		{
			wall_pos_hit = game->player.pos.y + ray_hit.distance * ray_dir.y;
			/*
			double x_offset = (ray_hit.distance /  get_vector_length(get_dda_distances(ray_dir))) * get_dda_x_distance(ray_dir);
			// x_offset - floor(x_offset) = value between 0 and 1
			//printf("Ray %d, player pos x - x offset: %f\n", x, game->player.pos.x - x_offset);
			rel_player_pos = game->player.pos.x - (double)((int)game->player.pos.x);
			wall_pos_hit = rel_player_pos - floor(rel_player_pos);
			*/
		}
		else
		{
			wall_pos_hit = game->player.pos.x + ray_hit.distance * ray_dir.x;

			/*
			double y_offset = (ray_hit.distance /  get_vector_length(get_dda_distances(ray_dir))) * get_dda_y_distance(ray_dir);
			rel_player_pos = game->player.pos.y - y_offset;
			wall_pos_hit = rel_player_pos - floor(rel_player_pos);
			printf("Ray %d, wall pos hit = %f\n", x, wall_pos_hit);
			//wall_pos_hit = y_offset - floor(y_offset);
			*/
		}
		wall_pos_hit = wall_pos_hit - floor(wall_pos_hit);
		//printf("Ray %d wallX: %f\n", x, wall_pos_hit);

		// texture size is 32*32
		//int textureX = wall_pos_hit * 32.0;
		//print_elapsed("Time to calculate (us):", start);
		//printf("ray %d Offset: %f\n", x, wall_pos_hit);
		
		//if (x == 0)
		//{
		//	//printf("ray hit distance: %f\n", ray_hit.distance);
		//}
		//print_elapsed("\ncalcul: ", start);
		//drawline_from_distance(x, ray_hit.distance, wall_pos_hit/*worldMap[ray_hit.tile_hit.y][ray_hit.tile_hit.x]*/, ray_hit.side_hit);
		drawline_from_distance(x, wall_pos_hit, ray_hit, ray_dir);
		//print_elapsed("Time to add to image (us):", start);
		//print_elapsed("draw: ", start);
	}
	add_minimap(worldMap);
	mlx_clear_window(game->mlx, game->window);
	mlx_put_image_to_window(game->mlx, game->window, game->main_img.img, 0,0);
	mlx_put_image_to_window(game->mlx, game->window, game->minimap_img.img, 0, 0);
	//print_elapsed("put window: ", start);
}


/*
	If there is an intersection with a wall after going forward (or any side)
	Revert the movement (pos -= velocity since before we had pos += velocity)
	But don't reset the rotation, because we canstill look around
	if we hit a wall
*/

// mlx_mouse_get_pos(window, int *x, int *y)
int	get_x_mouse_offset(void *window)
{
	int	initial_pos;
	int	current_pos;
	int	trucinutile;
	int	offset;

	initial_pos = screenWidth / 2;
	mlx_mouse_get_pos(window, &current_pos, &trucinutile);
	offset = current_pos - initial_pos;
	// If mouse is more than 9/10 or less than 1/10 of the window put it back at center
	//printf("mouse y: %d\n", trucinutile);
	// offset between -1280/2 and 1280/2 => mouse_move 0 = start 1280 = end, so need to add 1280/2
	if (trucinutile < screenHeight / 4 || trucinutile > screenHeight / 4) // If mouse is in 1st or 4th quarter, center in on y
		mlx_mouse_move(window, offset + (screenWidth / 2), screenHeight / 2);
	if (offset >= (screenWidth - screenWidth / 10) / 2 || offset <= -(screenWidth - screenWidth / 10) / 2)
		mlx_mouse_move(window, screenWidth / 2, screenHeight / 2);
	else
		return (offset);
}

// If too much offset, we probably went from side to middle
/*
int	get_mouse_velocity(void *window)
{
	static int	prev_pos = 0;
	static int smooth_mouse_velo;
	int	current_pos;
	int	tmp;
	int	velo;

	current_pos = get_x_mouse_offset(window);
	tmp = prev_pos;
	prev_pos = current_pos;
	velo = current_pos - tmp;
	//printf("velo: %d, smooth velo: %d\n", velo, smooth_mouse_velo);
	if (smooth_mouse_velo - velo <= 100)
	{
		if (velo < 0)
			smooth_mouse_velo = velo;
		else if (velo > 0)
			smooth_mouse_velo = velo;
	}
	else
	{
		smooth_mouse_velo -= smooth_mouse_velo % 3;
		if (smooth_mouse_velo < 0)
			smooth_mouse_velo += 3;
		else if (smooth_mouse_velo > 0)
			smooth_mouse_velo -= 3;
		return (velo);
	}
	smooth_mouse_velo -= smooth_mouse_velo % 3;
	if (smooth_mouse_velo < 0)
		smooth_mouse_velo += 3;
	else if (smooth_mouse_velo > 0)
		smooth_mouse_velo -= 3;
	return (smooth_mouse_velo);
}
*/

int	get_mouse_velocity(void *window)
{
	static int	prev_pos = 0;
	static int smooth_mouse_velo;
	int	current_pos;
	int	tmp;
	int	velo;

	current_pos = get_x_mouse_offset(window);
	tmp = prev_pos;
	prev_pos = current_pos;
	velo = current_pos - tmp;
	if ((velo < 0 && velo > -150) || (velo > 0 && velo < 150))
		smooth_mouse_velo = velo;
	smooth_mouse_velo -= smooth_mouse_velo % 3;
	if (smooth_mouse_velo > 0)
		smooth_mouse_velo -= 3;
	else if (smooth_mouse_velo < 0)
		smooth_mouse_velo += 3;
	return (smooth_mouse_velo);
}

int loop_hook(t_game *game)
{
	
	//mlx_mouse_move(game->window, screenWidth / 2, screenHeight / 2);
	//printf("current pos (%f, %f), velocity (%f %f)\n", game->player.pos.x, game->player.pos.y, game->player.velocity.x, game->player.velocity.y);
	int mouse_velo = get_mouse_velocity(game->window);
	//printf("mouse velocity: %d\n", mouse_velo);
	
	if (mouse_velo <= -2)
	{
		game->player.directions.rotate_l = 1;
		game->player.directions.rotate_r = 0;
	}
	else if (mouse_velo >= 2)
	{
		game->player.directions.rotate_l = 0;
		game->player.directions.rotate_r = 1;
	}
	else
	{
		game->player.directions.rotate_l = 0;
		game->player.directions.rotate_r = 0;
	}

	if (game->player.directions.rotate_l == 1)
	{
		rotate_player(&game->player, -1);
	}
	if (game->player.directions.rotate_r == 1)
		rotate_player(&game->player, 1);
	game->player.pos.x += game->player.velocity.x * game->player.speed;
	game->player.pos.y += game->player.velocity.y * game->player.speed;
	if (has_intersection_with_wall(game->player.pos, worldMap))
	{
		game->player.pos.y -= game->player.velocity.y * game->player.speed;
		game->player.pos.x -= game->player.velocity.x * game->player.speed;
		/*if (game->player.directions.rotate_r == 1)
			rotate_player(&game->player, -1);
		if (game->player.directions.rotate_l == 1)
			rotate_player(&game->player, 1);
			*/
	//	printf("reset pos (%f, %f), velocity (%f %f)\n", game->player.pos.x, game->player.pos.y, game->player.velocity.x, game->player.velocity.y);
	}
	
	
	//struct timeval start;
	//gettimeofday(&start, NULL);
	do_render(game);
	//print_elapsed("Time to render (ms):", start);
	return (1);
}

int	key_release_event(int keycode, t_game *game)
{
	t_player	*player;

	player = &game->player;
	if (keycode == KEY_W)
	{
		game->player.directions.forward = 0;
		remove_velocity(player, player->direction.x, player->direction.y);
	}
	else if (keycode == KEY_S)
	{
		game->player.directions.backward = 0;
		remove_velocity(player, -player->direction.x, -player->direction.y);
	}
	else if (keycode == KEY_A)
	{
		game->player.directions.left = 0;
		remove_velocity(player, player->direction.y, -player->direction.x);
	}
	else if (keycode == KEY_D)
	{
		game->player.directions.right = 0;
		remove_velocity(player, -player->direction.y, player->direction.x);
	}
	else if (keycode == KEY_SHFT)
	{
		player->speed /= (double) SPEED_MULTIPLIER;
	}
	else if (keycode == KEY_CTRL)
	{
		player->speed *= (double) SPEED_MULTIPLIER;
	}
	else if (keycode == KEY_ARROW_LEFT)
	{
		game->player.directions.rotate_l = 0;
	}
	else if (keycode == KEY_ARROW_RIGHT)
	{
		game->player.directions.rotate_r = 0;
	}
}

int main()
{
	game.mlx = mlx_init();
	game.window = mlx_new_window(game.mlx, screenWidth, screenHeight, "Cub3D");
	game.main_img.img = mlx_new_image(game.mlx, screenWidth, screenHeight);
	game.main_img.addr = mlx_get_data_addr(game.main_img.img, &game.main_img.bits_per_pixel, &game.main_img.line_length, &game.main_img.endian);
	
	game.minimap_img.img = mlx_new_image(game.mlx, screenWidth, screenHeight);
	game.minimap_img.addr = mlx_get_data_addr(game.minimap_img.img, &game.minimap_img.bits_per_pixel, &game.minimap_img.line_length, &game.minimap_img.endian);
	
	for (int x = 0; x < screenWidth; x++)
	{
		for (int y = 0; y < screenHeight; y++)
		{
			mlx_put_pixel_img(&game.minimap_img, x, y, 0xFF000000);
		}
	}

	mlx_mouse_move(game.window, screenWidth / 2, screenHeight / 2);
	mlx_mouse_hide();
	
	game.player.pos.y = 12.5;
	game.player.pos.x = 1.5;
	game.player.direction.x = 1.0;
	game.player.direction.y = 0.0;
	game.player.cam_plane.x = 0.0;
	game.player.cam_plane.y = 0.66;
	game.player.speed = 1.0;

	do_render(&game);

	
	mlx_do_key_autorepeatoff(game.mlx);
	
	mlx_hook(game.window, 2, 0, &key_press_event, &game);
	mlx_hook(game.window, 3, 0, &key_release_event, &game);
	mlx_loop_hook(game.mlx, &loop_hook, &game);
	mlx_loop(game.mlx);
	
	//mlx_loop(game.mlx);
}
